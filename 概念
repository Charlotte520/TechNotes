1. 悲观锁 vs 乐观锁：
每次读写数据要加锁，效率低。 vs 字段+version，写回时检查version，相同则更新，否则重新读。适合冲突不多的情况，否则不断尝试反而降低性能。

2. LDAP：解决用户统一认证问题
树存储，按层查询，无事务，快。数据量大，易复制。适合读多写少。

3. Netty
单体应用：同一机器上进程内的函数调用，效率高。=》rpc：慢，用http协议，无用消息太多，效率低。=》精简协议，只发要调用的方法、参数。用socket。
java socket：blocking io：一个线程一个socket连接，连接很多时，占空间大，线程切换开销大。且大量线程处于等待数据的状态，资源浪费。=》non-blocking io：多路复用，一个线程处理多个socket。线程通过selector检查socket集合，哪个socket的数据ready，就去处理哪个socket。
java nio：要实现高性能rpc框架，要自定义调用协议、数据格式、次序。=》netty：基于nio的网络框架，封装nio底层细节。dubbo，基于netty的rpc框架。

4. 无状态
无状态方法：纯函数，相同的输入总得到相同的输出，不依赖于外界状态。适合单cpu并发、多cpu并行，易scale out。如http。
若要用session保存状态，如购物车，可将状态转移存储到另外地方，如redis，尽量使server无状态。
不可变对象：没有实例变量，或实例变量为final。该对象一旦创建不可修改，一旦修改返回新对象。 若实例变量的方法也是无状态方法，也可以。若要共享变量，可用threadlocal将变量存到线程中。

5. xml
dtd/schema：校验；xpath：快速找到特定节点；xsl/xslt：xml转换为其他格式，如html。
数据传输&交换（跨平台语言）；配置文件；描述任务和流程（如ant）；web service的接口描述；界面描述（微信xaml）。
=》数据交换用json（数据量小，简洁，但缺少数据验证）；配置文件用java annotation；soa被restful替代。

6.web 编程
web页面：html 结构、css 展示、js 行为。dom模型。通过模板生成页面。如何展示业务发来的数据。 
browser和server交互：http协议。Get,post请求；无状态协议，状态用cookie；http状态码；同步vs 异步。
url和代码映射：规则用代码、注解、配置定义。业务代码用mvc框架组织。数据验证、转换、绑定。对象转为xml/json string。
db访问：jdbc connection、statement、resultset。or mapping框架：hibernate、mybatis。ror activerecord。  表关联：一对多、一对一、多对多如何用oo表示。连接池、事务、锁等。

7. restful
传统url：面向过程，getBook、addBook等，以动词为主。
restful url：面向资源。get /books; get /books/1; post /books; put /books/1; delete /books/1。 服务端无状态，client每次请求将session一起发送。轻量。

8. tcp/ip
为什么要三次握手？确认双方都能双工通信。a先发给b（1），b回复a(2），b可确认a能发且b能收。a收到b的回复，可确认a能发且收，且b能收发。a再发给b（3）,b收到后确认a能收且b能发。
虚电路：建立虚拟连接，所有消息从同一通道发送。不发消息时，通道闲置。=》分组交换：不需要建立真正的连接通道，每个pkg的通道可能不一样，完全由中间节点确定下一路径。中间节点不保证可靠连接，消息可能失序、重复、丢失，由两个端点保证可靠。
可靠传输：数据编号；超时/失败重传；连续发送，窗口满暂停发，ack来移动窗口，继续发。回退N步协议：失败分组及其以后的全部重发。选择性重传：仅重传失败分组，其后的缓存。

9. cpu
批处理系统 =》多道程序：os将进程load到内存时修改内存地址（静态重定位）。内存紧缩时要移动进程=》动态重定位，需要记录每个进程的起始地址，并用专门的寄存器保存。 防止访问别的进程的内存地址 =》记录进程长度，判断是否越界。将寄存器、计算内存地址的方法，封装为MMU内存管理单元。
程序局部性原理（时间，空间） =》 分块装载，先装载最重要的代码，再按需装载其他。 虚拟内存，os管理 虚拟页->物理页，最常访问的页表放到cache；物理页不存在时，产生缺页中断，os从disk取页。 =》程序分为代码段、数据段、堆栈段、共享段，os记录段的起始位置、长度、段保护位，段内分页管理。程序访问不属于自己的段，产生segment fault，被os kill，并生成core dump。
















